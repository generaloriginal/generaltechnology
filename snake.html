<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Snake - Three.js Starter</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffffff;
      font-size: clamp(24px, 5vw, 32px);
      font-weight: bold;
      text-shadow: 0 0 4px #000;
      z-index: 10;
      padding: 5px 15px;
    }
    #gameOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 100;
      color: #ffffff;
      font-size: clamp(28px, 6vw, 40px);
      font-weight: bold;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #gameOverlay.show {
      display: flex;
    }
    #gameOverlay h2 {
      margin: 0 0 20px 0;
      font-size: clamp(36px, 8vw, 64px);
    }
    #gameOverlay p {
      margin: 10px 0;
      font-size: clamp(20px, 4.5vw, 32px);
    }
    #restartBtn {
      margin-top: 30px;
      padding: clamp(12px, 3vw, 18px) clamp(30px, 8vw, 50px);
      font-size: clamp(18px, 4vw, 24px);
      background: #00ff00;
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      touch-action: manipulation;
    }
    #restartBtn:hover {
      background: #00cc00;
    }
    #nameEntry {
      margin-top: 20px;
      display: none;
    }
    #nameEntry.show {
      display: block;
    }
    #nameEntry p {
      font-size: clamp(18px, 4vw, 24px);
      margin-bottom: 15px;
    }
    #version {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(255, 255, 255, 0.5);
      font-size: clamp(12px, 2vw, 16px);
      font-weight: normal;
      z-index: 10;
      padding: 5px 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
    }
    
    /* Mobile-specific adjustments */
    @media (max-width: 768px) {
      #score {
        top: 5px;
        font-size: 28px;
      }
      #gameOverlay {
        padding: 15px;
      }
      #gameOverlay h2 {
        font-size: 42px;
        margin-bottom: 15px;
      }
      #gameOverlay p {
        font-size: 22px;
      }
      #leaderboard {
        max-height: 250px;
      }
    }
    
    @media (max-width: 480px) {
      #score {
        font-size: 24px;
      }
      #gameOverlay h2 {
        font-size: 36px;
      }
      #gameOverlay p {
        font-size: 20px;
      }
    }
    #nameInput {
      padding: clamp(12px, 3vw, 15px) clamp(15px, 4vw, 20px);
      font-size: clamp(18px, 4vw, 22px);
      border: 2px solid #00ff00;
      border-radius: 5px;
      background: #000;
      color: #fff;
      text-align: center;
      width: clamp(200px, 60vw, 300px);
      margin: 10px;
    }
    #nameInput:focus {
      outline: none;
      border-color: #00cc00;
    }
    #submitNameBtn {
      padding: clamp(12px, 3vw, 15px) clamp(25px, 6vw, 35px);
      font-size: clamp(18px, 4vw, 22px);
      background: #00ff00;
      color: #000;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      margin-left: 10px;
      touch-action: manipulation;
    }
    #submitNameBtn:hover {
      background: #00cc00;
    }
    #leaderboard {
      margin-top: 30px;
      max-height: 300px;
      overflow-y: auto;
      width: 90%;
      max-width: 400px;
    }
    #leaderboard h3 {
      margin: 20px 0 10px 0;
      font-size: clamp(24px, 5vw, 36px);
      color: #00ff00;
    }
    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      padding: clamp(10px, 2.5vw, 12px) clamp(15px, 4vw, 20px);
      margin: 5px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      font-size: clamp(16px, 3.5vw, 22px);
    }
    .leaderboard-entry.highlight {
      background: rgba(0, 255, 0, 0.3);
      border: 2px solid #00ff00;
    }
    .leaderboard-rank {
      font-weight: bold;
      color: #00ff00;
      margin-right: 15px;
      min-width: 30px;
    }
    .leaderboard-name {
      flex: 1;
      text-align: left;
    }
    .leaderboard-score {
      font-weight: bold;
      color: #ffff00;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0 / 50</div>
  <div id="version">v1.0.5</div>
  <div id="gameOverlay">
    <h2 id="overlayTitle">Game Over!</h2>
    <p id="overlayMessage">You hit the wall!</p>
    <p>Final Score: <span id="finalScore">0</span></p>
    <div id="nameEntry">
      <p style="font-size: 20px; margin-bottom: 10px;">Enter your name for the leaderboard:</p>
      <input type="text" id="nameInput" placeholder="Your Name" maxlength="20" />
      <button id="submitNameBtn">Submit</button>
    </div>
    <div id="leaderboard"></div>
    <button id="restartBtn">Play Again</button>
  </div>

  <!-- Three.js from CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // === Basic setup ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x66ccff);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // Snake head - create a group to hold head and face features
    const snakeHeadGroup = new THREE.Group();
    
    // Snake head body
    const snakeHeadGeo = new THREE.SphereGeometry(1, 32, 32);
    const snakeHeadMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
    const snakeHead = new THREE.Mesh(snakeHeadGeo, snakeHeadMat);
    snakeHeadGroup.add(snakeHead);
    
    // More human-like face features
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
    const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac }); // Skin tone
    const hairMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 }); // Brown hair
    
    // Larger, more human-like eyes
    const eyeGeo = new THREE.SphereGeometry(0.25, 16, 16);
    
    // Left eye (bigger)
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.35, 0.15, 0.75);
    snakeHeadGroup.add(leftEye);
    const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), pupilMat);
    leftPupil.position.set(-0.35, 0.15, 0.82);
    snakeHeadGroup.add(leftPupil);
    
    // Right eye (bigger)
    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    rightEye.position.set(0.35, 0.15, 0.75);
    snakeHeadGroup.add(rightEye);
    const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), pupilMat);
    rightPupil.position.set(0.35, 0.15, 0.82);
    snakeHeadGroup.add(rightPupil);
    
    // Eyebrows
    const eyebrowGeo = new THREE.BoxGeometry(0.4, 0.08, 0.05);
    const eyebrowMat = new THREE.MeshStandardMaterial({ color: 0x2d1810 });
    const leftEyebrow = new THREE.Mesh(eyebrowGeo, eyebrowMat);
    leftEyebrow.position.set(-0.35, 0.4, 0.7);
    leftEyebrow.rotation.z = -0.2;
    snakeHeadGroup.add(leftEyebrow);
    const rightEyebrow = new THREE.Mesh(eyebrowGeo, eyebrowMat);
    rightEyebrow.position.set(0.35, 0.4, 0.7);
    rightEyebrow.rotation.z = 0.2;
    snakeHeadGroup.add(rightEyebrow);
    
    // Nose
    const noseGeo = new THREE.ConeGeometry(0.1, 0.3, 8);
    const nose = new THREE.Mesh(noseGeo, skinMat);
    nose.rotation.x = Math.PI / 2;
    nose.position.set(0, 0.05, 0.85);
    snakeHeadGroup.add(nose);
    
    // Mouth (more human-like)
    const mouthGeo = new THREE.TorusGeometry(0.2, 0.04, 8, 16, Math.PI);
    const mouthMat = new THREE.MeshStandardMaterial({ color: 0x8b0000 });
    const mouth = new THREE.Mesh(mouthGeo, mouthMat);
    mouth.rotation.x = Math.PI / 2;
    mouth.position.set(0, -0.25, 0.75);
    snakeHeadGroup.add(mouth);
    
    // Add some "hair" or head detail on top
    const hairGeo = new THREE.SphereGeometry(0.6, 16, 16);
    const hair = new THREE.Mesh(hairGeo, hairMat);
    hair.position.set(0, 0.5, 0.2);
    hair.scale.set(1, 0.6, 1.2);
    snakeHeadGroup.add(hair);
    
    // Add the group to scene instead of just the head
    snakeHeadGroup.position.set(0, 1, 0);
    scene.add(snakeHeadGroup);

    // Snake body segments
    const segmentCountStart = 0;
    const segmentSpacing = 2.0; // distance between segments in samples
    const segments = [];

    const segmentGeo = new THREE.SphereGeometry(0.8, 16, 16);
    const segmentMat = new THREE.MeshStandardMaterial({ color: 0x008800 });

    function addSegment() {
      const seg = new THREE.Mesh(segmentGeo, segmentMat);
      // Position segment on the ground like a snake
      seg.position.set(snakeHeadGroup.position.x, 0.8, snakeHeadGroup.position.z);
      scene.add(seg);
      segments.push(seg);
    }

    // Apple
    const appleGeo = new THREE.SphereGeometry(0.7, 16, 16);
    const appleMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const apple = new THREE.Mesh(appleGeo, appleMat);
    scene.add(apple);

    const arenaSize = 80;
    function randomApplePosition() {
      const x = (Math.random() * 2 - 1) * arenaSize;
      const z = (Math.random() * 2 - 1) * arenaSize;
      apple.position.set(x, 0.7, z);
    }
    randomApplePosition();

    // Game state
    let gameRunning = true;
    let gameWon = false;
    const WIN_SCORE = 50; // Win condition: eat 50 apples
    const TOP_SCORES_COUNT = 10; // Number of top scores to keep
    
    // Score
    let score = 0;
    let currentPlayerName = "";
    const scoreDiv = document.getElementById("score");
    const gameOverlay = document.getElementById("gameOverlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayMessage = document.getElementById("overlayMessage");
    const finalScoreSpan = document.getElementById("finalScore");
    const restartBtn = document.getElementById("restartBtn");
    const nameEntry = document.getElementById("nameEntry");
    const nameInput = document.getElementById("nameInput");
    const submitNameBtn = document.getElementById("submitNameBtn");
    const leaderboardDiv = document.getElementById("leaderboard");
    
    // Using Supabase for persistent server-side storage (free tier)
    // NOTE: The anon key is SAFE to expose - it's designed for client-side use
    // If GitHub flags it, you can allow it (it's a false positive)
    const SUPABASE_URL = 'https://bmnixnmqferqlcxublii.supabase.co';
    const SUPABASE_ANON_KEY = 'sb_publishable_IidrOPKjc9tkqOwjJMhrrQ_z35awXmc'; // Public anon key (safe to expose in client code)
    
    let useSupabase = false;
    
    // Check if Supabase is configured
    if (SUPABASE_URL && SUPABASE_URL !== 'YOUR_SUPABASE_URL' && 
        SUPABASE_ANON_KEY && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
      useSupabase = true;
      console.log("Using Supabase for server-side leaderboard");
    } else {
      console.log("Supabase not configured - using localStorage (fallback)");
    }
    
    // High score management - using Supabase API
    async function getHighScores() {
      if (useSupabase) {
        try {
          const response = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard?select=name,score,date&order=score.desc&limit=10`, {
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            const scores = await response.json();
            console.log("ðŸ“Š Fetched scores from Supabase:", scores.length, "entries");
            if (Array.isArray(scores) && scores.length > 0) {
              // Also cache in localStorage as backup
              localStorage.setItem("snakeHighScores", JSON.stringify(scores));
              return scores;
            } else if (Array.isArray(scores)) {
              console.log("ðŸ“­ No scores in database yet");
              return [];
            }
          } else {
            const errorText = await response.text();
            console.error("âŒ Error fetching from Supabase:", response.status, errorText);
          }
        } catch (error) {
          console.error("âŒ Error fetching scores from Supabase:", error);
        }
      }
      
      // Fallback to localStorage
      const scores = localStorage.getItem("snakeHighScores");
      return scores ? JSON.parse(scores) : [];
    }
    
    async function saveHighScores(scores) {
      // Save to localStorage first (always)
      localStorage.setItem("snakeHighScores", JSON.stringify(scores));
      
      if (useSupabase) {
        try {
          // Get current scores from server first
          const currentResponse = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard?select=id`, {
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
            }
          });
          
          let currentIds = [];
          if (currentResponse.ok) {
            const current = await currentResponse.json();
            currentIds = current.map(c => c.id);
          }
          
          // Delete all existing scores
          if (currentIds.length > 0) {
            const deleteResponse = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard?id=in.(${currentIds.join(',')})`, {
              method: 'DELETE',
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'Content-Type': 'application/json'
              }
            });
            
            if (!deleteResponse.ok) {
              const errorText = await deleteResponse.text();
              console.warn("âš ï¸ Could not delete old scores:", errorText);
            }
          }
          
          // Insert new scores - Supabase supports array inserts
          if (scores.length > 0) {
            // Prepare data - only send name, score, date (id and created_at are auto)
            const recordsToInsert = scores.map(s => ({
              name: String(s.name || "Anonymous"),
              score: parseInt(s.score) || 0,
              date: String(s.date || new Date().toLocaleDateString())
            }));
            
            console.log("ðŸ“¤ Inserting", recordsToInsert.length, "scores:", recordsToInsert);
            
            const response = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard`, {
              method: 'POST',
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'Content-Type': 'application/json',
                'Prefer': 'return=representation'
              },
              body: JSON.stringify(recordsToInsert)
            });
            
            if (response.ok) {
              const result = await response.json();
              console.log("âœ… Leaderboard updated! Saved", result.length, "entries to Supabase");
              return;
            } else {
              const errorText = await response.text();
              console.error("âŒ Error saving to Supabase:", response.status, errorText);
              console.error("   Tried to save:", JSON.stringify(recordsToInsert, null, 2));
            }
          } else {
            console.log("ðŸ“­ No scores to save (empty array)");
          }
        } catch (error) {
          console.error("âŒ Error saving scores to Supabase:", error);
        }
      }
      
      console.log("ðŸ’¾ Scores saved locally (Supabase not configured or unavailable)");
    }
    
    async function addHighScore(name, score) {
      console.log("ðŸŽ¯ addHighScore called with:", name, "score:", score);
      
      const scores = await getHighScores();
      const date = new Date().toLocaleDateString();
      
      // Remove any existing entry with same name and score (avoid duplicates)
      const filtered = scores.filter(s => !(s.name === name && s.score === score));
      filtered.push({ name: name || "Anonymous", score: score, date: date });
      
      // Sort by score (highest first)
      filtered.sort((a, b) => b.score - a.score);
      // Keep only top scores
      const topScores = filtered.slice(0, TOP_SCORES_COUNT);
      
      console.log("ðŸ’¾ Saving top scores:", topScores);
      await saveHighScores(topScores);
      return topScores;
    }
    
    async function isTopScore(score) {
      const scores = await getHighScores();
      // If less than 10 scores, always qualify
      if (scores.length < TOP_SCORES_COUNT) return true;
      // Check if score is higher than the lowest top score
      const lowestTopScore = scores[TOP_SCORES_COUNT - 1].score;
      return score > lowestTopScore;
    }
    
    async function displayLeaderboard(highlightIndex = -1) {
      const scores = await getHighScores();
      if (scores.length === 0) {
        leaderboardDiv.innerHTML = "<h3>Leaderboard</h3><p>No scores yet. Be the first!</p>";
        return;
      }
      
      let html = "<h3>Top " + TOP_SCORES_COUNT + " Scores</h3>";
      scores.forEach((entry, index) => {
        const highlight = index === highlightIndex ? "highlight" : "";
        html += `
          <div class="leaderboard-entry ${highlight}">
            <span class="leaderboard-rank">#${index + 1}</span>
            <span class="leaderboard-name">${entry.name}</span>
            <span class="leaderboard-score">${entry.score}</span>
          </div>
        `;
      });
      leaderboardDiv.innerHTML = html;
    }
    
    function updateScoreDisplay() {
      scoreDiv.textContent = "Score: " + score + " / " + WIN_SCORE;
    }
    updateScoreDisplay();
    
    let nameSubmitted = false; // Track if name has been submitted for this game
    
    async function gameOver(reason) {
      // Prevent multiple calls
      if (!gameRunning) {
        return; // Already game over, don't process again
      }
      
      gameRunning = false;
      nameSubmitted = false; // Reset for new game
      overlayTitle.textContent = "Game Over!";
      overlayMessage.textContent = reason;
      finalScoreSpan.textContent = score;
      
      // Check if score qualifies for leaderboard
      const qualifies = await isTopScore(score);
      if (qualifies && !nameSubmitted) {
        nameEntry.classList.add("show");
        nameInput.focus();
        nameInput.value = "";
      } else {
        nameEntry.classList.remove("show");
      }
      
      await displayLeaderboard();
      gameOverlay.classList.add("show");
    }
    
    async function gameWin() {
      // Prevent multiple calls
      if (!gameRunning) {
        return; // Already game over, don't process again
      }
      
      gameRunning = false;
      gameWon = true;
      nameSubmitted = false; // Reset for new game
      overlayTitle.textContent = "You Win! ðŸŽ‰";
      overlayMessage.textContent = "You ate " + WIN_SCORE + " apples!";
      finalScoreSpan.textContent = score;
      
      // Check if score qualifies for leaderboard
      const qualifies = await isTopScore(score);
      if (qualifies && !nameSubmitted) {
        nameEntry.classList.add("show");
        nameInput.focus();
        nameInput.value = "";
      } else {
        nameEntry.classList.remove("show");
      }
      
      await displayLeaderboard();
      gameOverlay.classList.add("show");
    }
    
    async function submitName() {
      // Prevent double submission
      if (nameSubmitted) {
        console.log("âš ï¸ Name already submitted for this game");
        return;
      }
      
      const name = nameInput.value.trim() || "Anonymous";
      currentPlayerName = name;
      
      // Mark as submitted immediately
      nameSubmitted = true;
      
      // Log the score being saved for debugging
      console.log("ðŸ’¾ Saving score:", name, score);
      
      // Hide name entry immediately to prevent re-submission
      nameEntry.classList.remove("show");
      nameInput.value = ""; // Clear the input
      submitNameBtn.disabled = true; // Disable button to prevent double-submit
      
      const updatedScores = await addHighScore(name, score);
      
      // Find the index of the newly added score
      const newIndex = updatedScores.findIndex(entry => 
        entry.name === name && entry.score === score
      );
      
      // Update leaderboard with highlight
      await displayLeaderboard(newIndex);
      
      // Re-enable button after a short delay (though it won't matter since nameSubmitted is true)
      setTimeout(() => {
        submitNameBtn.disabled = false;
      }, 1000);
    }
    
    submitNameBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      submitName();
    });
    nameInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        e.stopPropagation();
        submitName();
      }
    });
    
    function restartGame() {
      // FIRST: Stop the game and reset position BEFORE restarting
      gameRunning = false;
      
      // Reset snake position IMMEDIATELY (before game starts)
      snakeHeadGroup.position.set(0, 1, 0);
      snakeHeadGroup.rotation.y = 0;
      
      // Clear body segments
      segments.forEach(seg => scene.remove(seg));
      segments.length = 0;
      headPositions.length = 0; // Clear position history
      
      // Reset input
      turnInput = 0;
      isPointerDown = false;
      
      // Reset game state
      gameWon = false;
      nameSubmitted = false;
      score = 0;
      updateScoreDisplay();
      
      // Reset apple position
      randomApplePosition();
      
      // Hide overlay and name entry
      gameOverlay.classList.remove("show");
      nameEntry.classList.remove("show");
      submitNameBtn.disabled = false;
      
      // NOW start the game (after everything is reset)
      gameRunning = true;
      
      console.log("ðŸ”„ Game restarted - snake at center:", snakeHeadGroup.position);
    }
    
    restartBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      restartGame();
    });

    // Head path history for body following
    const headPositions = [];
    const maxHistory = 10000; // large buffer

    // Movement
    const clock = new THREE.Clock();
    let snakeSpeed = 10; // units per second
    let turnInput = 0;   // -1 to +1 based on drag

    // Input handling (mouse + touch)
    let isPointerDown = false;
    let lastPointerX = 0;

    function onPointerDown(x) {
      if (!gameRunning) return;
      isPointerDown = true;
      lastPointerX = x;
    }

    function onPointerMove(x) {
      if (!isPointerDown || !gameRunning) return;
      const deltaX = x - lastPointerX;
      lastPointerX = x;
      // Adjust sensitivity as needed
      const sensitivity = 0.002;
      turnInput = deltaX * sensitivity;
    }

    function onPointerUp() {
      isPointerDown = false;
      turnInput = 0;
    }

    // Mouse events
    window.addEventListener("mousedown", (e) => onPointerDown(e.clientX));
    window.addEventListener("mousemove", (e) => onPointerMove(e.clientX));
    window.addEventListener("mouseup", onPointerUp);

    // Touch events
    window.addEventListener("touchstart", (e) => {
      if (e.touches.length > 0) {
        onPointerDown(e.touches[0].clientX);
      }
    });
    window.addEventListener("touchmove", (e) => {
      if (e.touches.length > 0) {
        onPointerMove(e.touches[0].clientX);
      }
    });
    window.addEventListener("touchend", onPointerUp);
    window.addEventListener("touchcancel", onPointerUp);

    // Camera offset
    const cameraOffset = new THREE.Vector3(0, 8, -15);

    // Helper vector reused
    const forward = new THREE.Vector3();

    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Always render the scene, even when game is paused/stopped
      if (!gameRunning) {
        // Still update camera to follow snake (even when stopped)
        const desiredCameraPos = cameraOffset.clone();
        desiredCameraPos.applyEuler(snakeHeadGroup.rotation);
        desiredCameraPos.add(snakeHeadGroup.position);
        camera.position.lerp(desiredCameraPos, 0.1);
        camera.lookAt(snakeHeadGroup.position);
        renderer.render(scene, camera);
        return;
      }
      
      const deltaTime = clock.getDelta();

      // Rotate snake based on input (yaw around Y)
      snakeHeadGroup.rotation.y -= turnInput; // sign chosen for natural feel

      // Move snake forward
      forward.set(0, 0, 1);
      forward.applyEuler(snakeHeadGroup.rotation);
      forward.normalize();
      snakeHeadGroup.position.addScaledVector(forward, snakeSpeed * deltaTime);

      // Check wall collision (end game if outside bounds) - make it get much closer to wall
      // Zero radius means head center must cross wall boundary before collision
      const headRadius = 0; // Head must actually cross wall boundary
      
      if (snakeHeadGroup.position.x <= -arenaSize + headRadius || 
          snakeHeadGroup.position.x >= arenaSize - headRadius ||
          snakeHeadGroup.position.z <= -arenaSize + headRadius || 
          snakeHeadGroup.position.z >= arenaSize - headRadius) {
        gameOver("You hit the wall!");
        return;
      }
      
      // Clamp position to prevent going further out
      snakeHeadGroup.position.x = Math.max(-arenaSize + headRadius, Math.min(arenaSize - headRadius, snakeHeadGroup.position.x));
      snakeHeadGroup.position.z = Math.max(-arenaSize + headRadius, Math.min(arenaSize - headRadius, snakeHeadGroup.position.z));

      // Record head position in history (only X and Z, Y stays constant for snake-like movement)
      const headPos = snakeHeadGroup.position.clone();
      headPos.y = 1.0; // Keep head at consistent height
      headPositions.push(headPos);
      if (headPositions.length > maxHistory) {
        headPositions.shift();
      }

      // Update body segment positions - keep them on the ground like a snake
      for (let i = 0; i < segments.length; i++) {
        const index = headPositions.length - 1 - (i + 1) * segmentSpacing;
        if (index < 0) continue;
        const pos = headPositions[Math.floor(index)];
        // Keep segments on the ground (Y = 0.8 for 0.8 radius sphere to sit on ground)
        segments[i].position.set(pos.x, 0.8, pos.z);
      }

      // Apple collision
      const eatRadius = 1.5;
      if (snakeHeadGroup.position.distanceTo(apple.position) < eatRadius) {
        // Eat apple
        score += 1;
        updateScoreDisplay();
        addSegment();
        randomApplePosition();
        
        // Check win condition
        if (score >= WIN_SCORE) {
          gameWin();
          return;
        }
      }

      // Camera follow
      const desiredCameraPos = cameraOffset.clone();
      desiredCameraPos.applyEuler(snakeHeadGroup.rotation);
      desiredCameraPos.add(snakeHeadGroup.position);

      camera.position.lerp(desiredCameraPos, 0.1);
      camera.lookAt(snakeHeadGroup.position);

      renderer.render(scene, camera);
    }

    animate();
    
    // Initialize leaderboard on page load
    displayLeaderboard().catch(err => console.error("Error loading leaderboard:", err));

    // Handle resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
