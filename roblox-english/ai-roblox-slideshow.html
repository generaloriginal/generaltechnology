<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Roblox - HTML Slideshow</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    .stage { position: relative; width: 100vw; height: 100vh; }

    /* Full-slide video */
    .slide {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain; /* preserve entire video frame */
      background: #000;
      opacity: 0;
      transition: opacity 250ms ease;
    }
    .slide.active { opacity: 1; }

    /* Overlay layer (interactive) */
    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: auto;
    }
    .hotspot-layer,
    .fx-layer {
      position: absolute;
      inset: 0;
    }
    .hotspot-layer { pointer-events: auto; }
    .fx-layer { pointer-events: none; }

    .hotspot {
      position: absolute;
      cursor: pointer;
      background: rgba(255,255,255,0);
    }
    .hotspot.quiz-launch {
      background: rgba(255,255,255,0.92);
      color: #111;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font: 16px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 600;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
      user-select: none;
    }
    .overlay.debug .hotspot {
      outline: 2px dashed rgba(255,255,255,0.75);
      background: rgba(255,255,255,0.12);
    }

    .meme-layer {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .meme-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.65);
      backdrop-filter: blur(3px);
    }
    .meme-img {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      opacity: 0;
      transform: scale(0.96);
      transition: opacity 200ms ease, transform 200ms ease;
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.45);
    }
    .meme-img.show {
      opacity: 1;
      transform: scale(1);
    }
    .anim-video {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      opacity: 0;
      transform: scale(0.96);
      transition: opacity 200ms ease, transform 200ms ease;
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.45);
      background: #000;
    }
    .anim-video.show {
      opacity: 1;
      transform: scale(1);
    }
    .quiz-layer {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }
    .quiz-card {
      position: relative;
      width: min(560px, 92vw);
      background: rgba(0,0,0,0.85);
      color: #fff;
      border-radius: 16px;
      padding: 18px 18px 16px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.45);
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      cursor: grab;
      touch-action: none;
    }
    .quiz-card.dragging {
      cursor: grabbing;
    }
    .quiz-title {
      font-weight: 700;
      margin-bottom: 10px;
      opacity: 0.9;
    }
    .quiz-prompt {
      font-size: 18px;
      margin-bottom: 12px;
    }
    .quiz-choices {
      display: grid;
      gap: 10px;
    }
    .quiz-choice {
      border: none;
      border-radius: 10px;
      padding: 10px 12px;
      font: 16px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      cursor: pointer;
      background: #fff;
      color: #111;
    }
    .quiz-choice.wrong {
      background: #ff6b6b;
      color: #fff;
    }
    .quiz-choice.correct {
      background: #3ecf8e;
      color: #0b1f16;
    }
    .quiz-status {
      margin-top: 10px;
      font-size: 14px;
      opacity: 0.8;
    }

  </style>
</head>

<body>
  <div class="stage" id="stage">
    <div class="overlay" id="overlay"></div>

  </div>

  <script>
    const DEBUG_HOTSPOTS = false;
    const TENOR_API_KEY = "LIVDSRZULELA";
    const DEFAULT_MEME_QUERY = "jump meme";
    const MEME_LIMIT = 12;
    const MEME_MAX_REROLL = 4;
    const MEME_LIFETIME_MS = 3500;
    const HOTSPOTS_URL = "hotspots.json";
    const QUIZ_QUESTIONS = [
      {
        prompt: "The ___ is shining in the sky.",
        choices: ["sun", "fire", "mushroom", "house"],
        answer: "sun"
      },
      {
        prompt: "There are five red ___ in the top right corner.",
        choices: ["flowers", "hearts", "clouds", "trees"],
        answer: "hearts"
      },
      {
        prompt: "The character is standing next to a small ___ with flowers.",
        choices: ["car", "house", "tree", "cloud"],
        answer: "house"
      },
      {
        prompt: "The word ___ is written on one of the buttons.",
        choices: ["sleep", "read", "jump", "eat"],
        answer: "jump"
      }
    ];

    const slideFiles = [
      "slide-videos/Copy of Copy of A1 - ROBLOX 2.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 3.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 5.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 7.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 9.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 11.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 13.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 15.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 17.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 19.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 19.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 19.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 21.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 23.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 25.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 27.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 29.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 31.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 33.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 35.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 37.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 39.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 41.MP4",
      "slide-videos/Copy of Copy of A1 - ROBLOX 43.MP4"
    ];

    const stage = document.getElementById("stage");
    const overlay = document.getElementById("overlay");

    let index = 0;
    let hotspotLayer = null;
    let fxLayer = null;
    let slides = [];
    let slideEls = [];

    const FALLBACK_HOTSPOTS = {
      "9": [
        { id: "jump", action: "meme", query: "jump meme",  x: 0.3277, y: 0.4156, w: 0.1582, h: 0.0721, text: "JUMP" },
        { id: "run", action: "meme", query: "run meme",   x: 0.3277, y: 0.4836, w: 0.1582, h: 0.0721, text: "RUN" },
        { id: "buy", action: "meme", query: "buy meme",   x: 0.5141, y: 0.4156, w: 0.1582, h: 0.0721, text: "BUY" },
        { id: "build", action: "meme", query: "build meme", x: 0.5141, y: 0.4836, w: 0.1582, h: 0.0721, text: "BUILD" }
      ],
      "10": [
        { id: "jump_anim", action: "anim", video: "slide-animations/Jump.mp4",  x: 0.3277, y: 0.4156, w: 0.1582, h: 0.0721, text: "JUMP" },
        { id: "run_anim", action: "anim", video: "slide-animations/Run.mp4",   x: 0.3277, y: 0.4836, w: 0.1582, h: 0.0721, text: "RUN" },
        { id: "buy_anim", action: "anim", video: "slide-animations/Buy.mp4",   x: 0.5141, y: 0.4156, w: 0.1582, h: 0.0721, text: "BUY" },
        { id: "build_anim", action: "anim", video: "slide-animations/Build.mp4", x: 0.5141, y: 0.4836, w: 0.1582, h: 0.0721, text: "BUILD" }
      ],
      "11": [
        { id: "quiz_button", action: "quiz", label: "Questions", rewardQuery: "jump meme", questions: QUIZ_QUESTIONS, x: 0.39, y: 0.8, w: 0.22, h: 0.1, text: "QUESTIONS" }
      ]
    };

    async function loadHotspots() {
      try {
        const res = await fetch(HOTSPOTS_URL, { cache: "no-store" });
        if (!res.ok) throw new Error("hotspots load failed");
        return await res.json();
      } catch (err) {
        return FALLBACK_HOTSPOTS;
      }
    }

    async function init() {
      const hotspotsBySlide = await loadHotspots();
      if (!hotspotsBySlide["9"] || hotspotsBySlide["9"].length === 0) {
        hotspotsBySlide["9"] = FALLBACK_HOTSPOTS["9"];
      }
      if (!hotspotsBySlide["10"] || hotspotsBySlide["10"].length === 0) {
        hotspotsBySlide["10"] = FALLBACK_HOTSPOTS["10"];
      }
      if (!hotspotsBySlide["11"] || hotspotsBySlide["11"].length === 0) {
        hotspotsBySlide["11"] = FALLBACK_HOTSPOTS["11"];
      }
      slides = slideFiles.map((src, i) => ({
        src,
        hotspots: hotspotsBySlide[String(i)] || []
      }));

      slideEls = slides.map((slide, i) => {
        const v = document.createElement("video");
        v.className = "slide" + (i === 0 ? " active" : "");
        v.src = encodeURI(slide.src);
        v.preload = "auto";
        v.loop = true;
        v.muted = true;
        v.playsInline = true;
        v.dataset.index = String(i);
        v.addEventListener("loadedmetadata", () => {
          if (i === index) renderHotspots();
        });
        stage.insertBefore(v, overlay);
        return v;
      });

      show(0);
    }

    // Given stage size and slide aspect ratio, compute the rendered "contain" rectangle
    function getContainRect(stageW, stageH, imgW, imgH) {
      const imgAR = imgW / imgH;
      const stageAR = stageW / stageH;

      let drawW, drawH, offX, offY;
      if (stageAR > imgAR) {
        // stage wider -> image fits height
        drawH = stageH;
        drawW = drawH * imgAR;
        offX = (stageW - drawW) / 2;
        offY = 0;
      } else {
        // stage taller -> image fits width
        drawW = stageW;
        drawH = drawW / imgAR;
        offX = 0;
        offY = (stageH - drawH) / 2;
      }
      return { drawW, drawH, offX, offY };
    }

    function resetOverlay() {
      overlay.innerHTML = "";
      overlay.dataset.slide = String(index + 1);
      overlay.classList.toggle("debug", DEBUG_HOTSPOTS);

      hotspotLayer = document.createElement("div");
      hotspotLayer.className = "hotspot-layer";
      fxLayer = document.createElement("div");
      fxLayer.className = "fx-layer";
      overlay.appendChild(hotspotLayer);
      overlay.appendChild(fxLayer);
    }

    function renderHotspots() {
      if (!hotspotLayer) return;
      hotspotLayer.innerHTML = "";

      if (!slides.length) return;
      const current = slides[index];
      if (!current.hotspots || current.hotspots.length === 0) return;

      const v = slideEls[index];
      const stageRect = stage.getBoundingClientRect();
      const vw = v.videoWidth || 1920;
      const vh = v.videoHeight || 1080;
      const { drawW, drawH, offX, offY } = getContainRect(
        stageRect.width,
        stageRect.height,
        vw,
        vh
      );

      current.hotspots.forEach((spot) => {
        const el = document.createElement("div");
        el.className = "hotspot";
        el.dataset.action = spot.action;
        if (spot.query) el.dataset.query = spot.query;
        if (spot.video) el.dataset.video = spot.video;
        el._spot = spot;
        if (spot.label) {
          el.textContent = spot.label;
          el.classList.add("quiz-launch");
        }
        el.style.left = `${offX + spot.x * drawW}px`;
        el.style.top = `${offY + spot.y * drawH}px`;
        el.style.width = `${spot.w * drawW}px`;
        el.style.height = `${spot.h * drawH}px`;
        hotspotLayer.appendChild(el);
      });
    }

    let overlayActive = false;
    let currentOverlayLayer = null;
    let currentOverlayMedia = null;
    let currentOverlayType = null;
    const lastMemeByQuery = {};
    async function fetchMemeUrl(query) {
      const params = new URLSearchParams({
        q: query,
        key: TENOR_API_KEY,
        limit: String(MEME_LIMIT)
      });
      const res = await fetch(`https://g.tenor.com/v1/search?${params}`);
      if (!res.ok) throw new Error(`meme search failed (${res.status})`);
      const data = await res.json();
      const results = (data && data.results) || [];
      if (results.length === 0) return "";

      const pickUrl = (result) => {
        const media = result && result.media && result.media[0];
        const gif =
          (media && (media.gif || media.mediumgif || media.tinygif || media.nanogif || media.webp)) ||
          null;
        return (gif && gif.url) || "";
      };

      let url = "";
      const lastUrl = lastMemeByQuery[query] || "";
      const attempts = Math.min(results.length, MEME_MAX_REROLL + 1);
      for (let i = 0; i < attempts; i += 1) {
        const candidate = results[Math.floor(Math.random() * results.length)];
        url = pickUrl(candidate);
        if (url && url !== lastUrl) break;
      }
      if (!url) url = pickUrl(results[0]) || "";
      if (url) lastMemeByQuery[query] = url;
      return url;
    }

    function clearOverlay() {
      if (!currentOverlayLayer) return;
      if (currentOverlayMedia && currentOverlayMedia.pause) {
        currentOverlayMedia.pause();
      }
      if (currentOverlayMedia) {
        currentOverlayMedia.remove();
        currentOverlayMedia = null;
      }
      currentOverlayLayer.remove();
      currentOverlayLayer = null;
      currentOverlayType = null;
      overlayActive = false;
    }

    async function showMeme(query) {
      if (!fxLayer || overlayActive) return;
      overlayActive = true;
      currentOverlayType = "meme";
      fxLayer.innerHTML = "";

      const layer = document.createElement("div");
      layer.className = "meme-layer";
      currentOverlayLayer = layer;
      const backdrop = document.createElement("div");
      backdrop.className = "meme-backdrop";
      layer.appendChild(backdrop);
      fxLayer.appendChild(layer);

      try {
        const url = await fetchMemeUrl(query);
        if (!url) throw new Error("no meme url");
        const img = document.createElement("img");
        img.className = "meme-img";
        img.alt = "Jump meme";
        img.decoding = "async";
        img.src = url;
        currentOverlayMedia = img;
        img.onload = () => { img.classList.add("show"); };
        img.onerror = () => { clearOverlay(); };
        layer.appendChild(img);
      } catch (err) {
        clearOverlay();
      }

      setTimeout(() => {
        if (currentOverlayLayer === layer) {
          clearOverlay();
        }
      }, MEME_LIFETIME_MS);
    }

    function showAnimation(videoSrc) {
      if (!fxLayer || overlayActive) return;
      overlayActive = true;
      currentOverlayType = "anim";
      fxLayer.innerHTML = "";

      const layer = document.createElement("div");
      layer.className = "meme-layer";
      currentOverlayLayer = layer;

      const backdrop = document.createElement("div");
      backdrop.className = "meme-backdrop";
      layer.appendChild(backdrop);

      const video = document.createElement("video");
      video.className = "anim-video";
      video.src = encodeURI(videoSrc);
      video.autoplay = true;
      video.loop = true;
      video.muted = true;
      video.playsInline = true;
      video.onloadeddata = () => video.classList.add("show");
      currentOverlayMedia = video;
      layer.appendChild(video);

      fxLayer.appendChild(layer);
    }

    function showQuiz(spot) {
      const questions = (spot && spot.questions) || [];
      if (!fxLayer || overlayActive || questions.length === 0) return;
      overlayActive = true;
      currentOverlayType = "quiz";
      fxLayer.innerHTML = "";

      const layer = document.createElement("div");
      layer.className = "quiz-layer";
      currentOverlayLayer = layer;

      const card = document.createElement("div");
      card.className = "quiz-card";
      layer.appendChild(card);

      const title = document.createElement("div");
      title.className = "quiz-title";
      card.appendChild(title);

      const promptEl = document.createElement("div");
      promptEl.className = "quiz-prompt";
      card.appendChild(promptEl);

      const choicesEl = document.createElement("div");
      choicesEl.className = "quiz-choices";
      card.appendChild(choicesEl);

      const statusEl = document.createElement("div");
      statusEl.className = "quiz-status";
      card.appendChild(statusEl);

      fxLayer.appendChild(layer);

      let qIndex = 0;
      const rewardQuery = spot.rewardQuery || spot.query || DEFAULT_MEME_QUERY;

      const centerCard = () => {
        const rect = card.getBoundingClientRect();
        card.style.left = `${(window.innerWidth - rect.width) / 2}px`;
        card.style.top = `${(window.innerHeight - rect.height) / 2}px`;
      };

      requestAnimationFrame(centerCard);

      let dragActive = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      const startDrag = (e) => {
        if (e.target && e.target.classList && e.target.classList.contains("quiz-choice")) return;
        dragActive = true;
        card.classList.add("dragging");
        const rect = card.getBoundingClientRect();
        card.style.left = `${rect.left}px`;
        card.style.top = `${rect.top}px`;
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        if (card.setPointerCapture) card.setPointerCapture(e.pointerId);
        e.preventDefault();
      };

      const moveDrag = (e) => {
        if (!dragActive) return;
        card.style.left = `${e.clientX - dragOffsetX}px`;
        card.style.top = `${e.clientY - dragOffsetY}px`;
      };

      const endDrag = (e) => {
        if (!dragActive) return;
        dragActive = false;
        card.classList.remove("dragging");
        if (card.releasePointerCapture && e.pointerId != null) {
          card.releasePointerCapture(e.pointerId);
        }
      };

      card.style.position = "absolute";
      card.addEventListener("pointerdown", startDrag);
      card.addEventListener("pointermove", moveDrag);
      card.addEventListener("pointerup", endDrag);
      card.addEventListener("pointercancel", endDrag);

      const renderQuestion = () => {
        const q = questions[qIndex];
        title.textContent = `Question ${qIndex + 1} / ${questions.length}`;
        promptEl.textContent = q.prompt;
        statusEl.textContent = "";
        choicesEl.innerHTML = "";

        q.choices.forEach((choice) => {
          const btn = document.createElement("button");
          btn.className = "quiz-choice";
          btn.textContent = choice;
          btn.addEventListener("click", () => {
            if (choice === q.answer) {
              btn.classList.add("correct");
              statusEl.textContent = "Correct!";
              setTimeout(() => {
                if (qIndex < questions.length - 1) {
                  qIndex += 1;
                  renderQuestion();
                } else {
                  clearOverlay();
                  showMeme(rewardQuery);
                }
              }, 350);
            } else {
              btn.classList.add("wrong");
              statusEl.textContent = "Try again.";
              setTimeout(() => btn.classList.remove("wrong"), 400);
            }
          });
          choicesEl.appendChild(btn);
        });
      };

      renderQuestion();
    }

    function show(i) {
      if (!slideEls.length) return;
      const next = Math.max(0, Math.min(slides.length - 1, i));
      slideEls[index].classList.remove("active");
      slideEls[index].pause();

      index = next;
      slideEls[index].classList.add("active");
      slideEls[index].play().catch(() => {});

      resetOverlay();
      renderHotspots();
    }

    function next() { show(index + 1); }
    function prev() { show(index - 1); }

    overlay.addEventListener("click", (e) => {
      if (currentOverlayLayer && currentOverlayType !== "quiz") {
        clearOverlay();
        return;
      }
      const target = e.target.closest && e.target.closest(".hotspot");
      if (!target) return;
      e.stopPropagation();
      const spot = target._spot || {};
      const action = target.dataset.action;
      if (action === "meme") showMeme(target.dataset.query || DEFAULT_MEME_QUERY);
      if (action === "anim") showAnimation(target.dataset.video);
      if (action === "quiz") showQuiz(spot);
    });

    stage.addEventListener("click", (e) => {
      if (!currentOverlayLayer || currentOverlayType === "quiz") return;
      e.preventDefault();
      e.stopPropagation();
      clearOverlay();
    }, true);

    window.addEventListener("resize", () => renderHotspots(), { passive: true });

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight" || e.key === " " || e.key === "PageDown") { e.preventDefault(); next(); }
      if (e.key === "ArrowLeft"  || e.key === "PageUp") { e.preventDefault(); prev(); }
      if (e.key === "Home") { e.preventDefault(); show(0); }
      if (e.key === "End") { e.preventDefault(); show(slides.length - 1); }
    });

    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartAt = 0;
    const SWIPE_MIN_PX = 40;
    const SWIPE_MAX_MS = 1000;

    stage.addEventListener("touchstart", (e) => {
      if (!e.touches || e.touches.length !== 1) return;
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
      touchStartAt = Date.now();
    }, { passive: true });

    stage.addEventListener("touchend", (e) => {
      if (currentOverlayLayer) return;
      const t = e.changedTouches && e.changedTouches[0];
      if (!t) return;
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const dt = Date.now() - touchStartAt;
      if (dt > SWIPE_MAX_MS) return;
      if (Math.abs(dx) < SWIPE_MIN_PX) return;
      if (Math.abs(dx) < Math.abs(dy)) return;
      dx < 0 ? next() : prev();
    }, { passive: true });

    // Start
    init();
  </script>
</body>
</html>
